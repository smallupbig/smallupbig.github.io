<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类 | 跳一跳的猪的博客</title>
    <meta name="description" content="Hello World">
    <link rel="icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.0822f0c7.css" as="style"><link rel="preload" href="/assets/js/app.95515c58.js" as="script"><link rel="preload" href="/assets/js/2.1e63c646.js" as="script"><link rel="preload" href="/assets/js/11.7d9955f5.js" as="script"><link rel="prefetch" href="/assets/js/10.63c10e9a.js"><link rel="prefetch" href="/assets/js/12.f40b8dc7.js"><link rel="prefetch" href="/assets/js/13.bd10cedd.js"><link rel="prefetch" href="/assets/js/14.ca04ea7b.js"><link rel="prefetch" href="/assets/js/15.057b383c.js"><link rel="prefetch" href="/assets/js/16.17f85a0e.js"><link rel="prefetch" href="/assets/js/17.00380992.js"><link rel="prefetch" href="/assets/js/18.02ac9a73.js"><link rel="prefetch" href="/assets/js/19.49a49d79.js"><link rel="prefetch" href="/assets/js/20.8c5d19b0.js"><link rel="prefetch" href="/assets/js/21.23feb2ff.js"><link rel="prefetch" href="/assets/js/22.7943b80e.js"><link rel="prefetch" href="/assets/js/23.19abfcba.js"><link rel="prefetch" href="/assets/js/24.a8b7c3a2.js"><link rel="prefetch" href="/assets/js/25.245c92f0.js"><link rel="prefetch" href="/assets/js/26.5f3536b1.js"><link rel="prefetch" href="/assets/js/27.81ed09c2.js"><link rel="prefetch" href="/assets/js/28.eac509c8.js"><link rel="prefetch" href="/assets/js/29.6a3135ea.js"><link rel="prefetch" href="/assets/js/3.f173e7b6.js"><link rel="prefetch" href="/assets/js/30.9d52e7b2.js"><link rel="prefetch" href="/assets/js/31.4ad32a16.js"><link rel="prefetch" href="/assets/js/32.a8037ea1.js"><link rel="prefetch" href="/assets/js/33.b2e21ebf.js"><link rel="prefetch" href="/assets/js/34.fdfe7603.js"><link rel="prefetch" href="/assets/js/35.3466d40b.js"><link rel="prefetch" href="/assets/js/36.8cb79e41.js"><link rel="prefetch" href="/assets/js/37.18705617.js"><link rel="prefetch" href="/assets/js/38.f76854ed.js"><link rel="prefetch" href="/assets/js/39.989f5c0b.js"><link rel="prefetch" href="/assets/js/4.bb9dbcd4.js"><link rel="prefetch" href="/assets/js/40.b2a9a658.js"><link rel="prefetch" href="/assets/js/5.966df546.js"><link rel="prefetch" href="/assets/js/6.f9219fb0.js"><link rel="prefetch" href="/assets/js/7.f7f0e67b.js"><link rel="prefetch" href="/assets/js/8.11a2bc7e.js"><link rel="prefetch" href="/assets/js/9.031d86af.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0822f0c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">跳一跳的猪的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">C</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/C/基础/" class="nav-link">基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSharp</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSharp/DotNetCore/" class="nav-link">DotNetCore</a></li><li class="dropdown-item"><!----> <a href="/CSharp/基础/" class="nav-link">基础</a></li><li class="dropdown-item"><!----> <a href="/CSharp/练习/" class="nav-link">练习</a></li></ul></div></div><div class="nav-item"><a href="/JS/" class="nav-link">JS</a></div><div class="nav-item"><a href="/Linux/" class="nav-link">Linux</a></div><div class="nav-item"><a href="/MySql/" class="nav-link">MySql</a></div><div class="nav-item"><a href="/Python/" class="nav-link">Python</a></div><div class="nav-item"><a href="/其他/" class="nav-link">其他</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">C</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/C/基础/" class="nav-link">基础</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">CSharp</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/CSharp/DotNetCore/" class="nav-link">DotNetCore</a></li><li class="dropdown-item"><!----> <a href="/CSharp/基础/" class="nav-link">基础</a></li><li class="dropdown-item"><!----> <a href="/CSharp/练习/" class="nav-link">练习</a></li></ul></div></div><div class="nav-item"><a href="/JS/" class="nav-link">JS</a></div><div class="nav-item"><a href="/Linux/" class="nav-link">Linux</a></div><div class="nav-item"><a href="/MySql/" class="nav-link">MySql</a></div><div class="nav-item"><a href="/Python/" class="nav-link">Python</a></div><div class="nav-item"><a href="/其他/" class="nav-link">其他</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/CSharp/%E5%9F%BA%E7%A1%80/" class="sidebar-link">前言</a></li><li><a href="/CSharp/基础/String常用操作.html" class="sidebar-link">String 常用操作</a></li><li><a href="/CSharp/基础/out 和 ref.html" class="sidebar-link">out 和 ref</a></li><li><a href="/CSharp/基础/枚举.html" class="sidebar-link">枚举</a></li><li><a href="/CSharp/基础/类.html" class="active sidebar-link">类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#属性和关联的字段" class="sidebar-link">属性和关联的字段</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#属性和公共字段" class="sidebar-link">属性和公共字段</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#自动实现属性" class="sidebar-link">自动实现属性</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#静态属性" class="sidebar-link">静态属性</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#实例构造函数" class="sidebar-link">实例构造函数</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#带参数的构造函数" class="sidebar-link">带参数的构造函数</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#默认构造函数" class="sidebar-link">默认构造函数</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#静态构造函数" class="sidebar-link">静态构造函数</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#对象初始化语句" class="sidebar-link">对象初始化语句</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#析构函数" class="sidebar-link">析构函数</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#readonly-修饰符" class="sidebar-link">readonly 修饰符</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#this-关键字" class="sidebar-link">this 关键字</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#索引器" class="sidebar-link">索引器</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#声明索引器" class="sidebar-link">声明索引器</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#索引器重载" class="sidebar-link">索引器重载</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#访问器的访问修饰符" class="sidebar-link">访问器的访问修饰符</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#分部类和分布类型" class="sidebar-link">分部类和分布类型</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#分部方法" class="sidebar-link">分部方法</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#类和继承" class="sidebar-link">类和继承</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#虚方法和覆写方法" class="sidebar-link">虚方法和覆写方法</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#构造方法的执行" class="sidebar-link">构造方法的执行</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#构造函数初始化语句" class="sidebar-link">构造函数初始化语句</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#类访问修饰符" class="sidebar-link">类访问修饰符</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#程序集间的继承" class="sidebar-link">程序集间的继承</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#成员访问修饰符" class="sidebar-link">成员访问修饰符</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#抽象成员" class="sidebar-link">抽象成员</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#抽象类" class="sidebar-link">抽象类</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#密封类" class="sidebar-link">密封类</a></li><li class="sidebar-sub-header"><a href="/CSharp/基础/类.html#扩展类" class="sidebar-link">扩展类</a></li></ul></li><li><a href="/CSharp/基础/结构.html" class="sidebar-link">结构</a></li><li><a href="/CSharp/基础/装箱和拆箱.html" class="sidebar-link">拆箱和装箱</a></li><li><a href="/CSharp/基础/问号.html" class="sidebar-link">三元表达式(?:)</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="类"><a href="#类" aria-hidden="true" class="header-anchor">#</a> 类</h1> <h2 id="属性和关联的字段"><a href="#属性和关联的字段" aria-hidden="true" class="header-anchor">#</a> 属性和关联的字段</h2> <p><strong>后备字段</strong>：和属性关联的字段,分配字段
<strong>属性</strong>不分配字段</p> <h2 id="属性和公共字段"><a href="#属性和公共字段" aria-hidden="true" class="header-anchor">#</a> 属性和公共字段</h2> <p>按照推荐的编程实践，属性比公共字段好：</p> <ul><li>属性是函数成员，而不是数据成员，可以进行输入和输出，而公共字段不行</li> <li>属性可以只读和只写，公共字段不行</li> <li>编译后的变量和编译后的属性语义不同</li></ul> <h2 id="自动实现属性"><a href="#自动实现属性" aria-hidden="true" class="header-anchor">#</a> 自动实现属性</h2> <div class="language-C# extra-class"><pre class="language-text"><code>        clsss Test
        {
            public int MyValue
            {
                get;
                set;
            }


        }
</code></pre></div><ul><li>不声明后备字段,编译器会根据属性的类型分配存储</li> <li>不能提供访问器的方法体，他们必须被简单的声明为分号。</li> <li>除非通过访问器，否则不能访问后备字段</li></ul> <h2 id="静态属性"><a href="#静态属性" aria-hidden="true" class="header-anchor">#</a> 静态属性</h2> <ul><li>不能访问类的实例成员，可以被实例成员访问到</li> <li>不管类是否有实例，他们都是存在的</li> <li>当从类的外部访问时，必须使用类名引用，而不是实例名</li></ul> <h2 id="实例构造函数"><a href="#实例构造函数" aria-hidden="true" class="header-anchor">#</a> 实例构造函数</h2> <p>是一个特殊的方法，在创建类的每个新实例时执行</p> <ul><li>用于初始化类实例的状态</li> <li>如果希望能从类的外部创建类的实例，需要将构造函数声明为 public</li> <li>构造函数的名称和类的名称相同</li> <li>构造函数不能有返回值</li></ul> <h2 id="带参数的构造函数"><a href="#带参数的构造函数" aria-hidden="true" class="header-anchor">#</a> 带参数的构造函数</h2> <ul><li>构造函数可以带参数</li> <li>构造函数可以被重载</li></ul> <h2 id="默认构造函数"><a href="#默认构造函数" aria-hidden="true" class="header-anchor">#</a> 默认构造函数</h2> <ul><li>没有参数</li> <li>方法体为空</li> <li>如果声明了任何构造函数，则编译器将不会为该类定义默认构造函数</li></ul> <h2 id="静态构造函数"><a href="#静态构造函数" aria-hidden="true" class="header-anchor">#</a> 静态构造函数</h2> <p>构造函数可以声明为 static，实例构造函数初始化类的每个新实例，而 static 构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。</p> <ul><li><strong>初始化类级别的项</strong></li> <li><strong>在引用任何静态成员之前</strong></li> <li><strong>在创建类的任何实例之前</strong></li> <li>静态构造函数的名称必须和类名相同</li> <li>不能有返回值</li> <li>static关键字</li> <li><strong>只能有一个静态构造函数，且不能带参数</strong></li> <li>类既可以有静态构造函数，也可以有实例构造函数</li> <li>不能访问所在类的实例成员，因此也不能使用 this 访问器</li> <li>不能从程序中显式调用静态构造函数，系统会自动调用：
<ul><li>类的任何实例被创建之前</li> <li>类的任何静态成员被引用之前</li></ul></li></ul> <h2 id="对象初始化语句"><a href="#对象初始化语句" aria-hidden="true" class="header-anchor">#</a> 对象初始化语句</h2> <div class="language-c# extra-class"><pre class="language-text"><code>    new TypeName { x = 1, y =2}
    new TypeName() { x = 1, y =2 }
</code></pre></div><ul><li>创建对象必须能都访问要初始化的字段和属性</li> <li><strong>初始化发生在构造函数之后</strong></li></ul> <h2 id="析构函数"><a href="#析构函数" aria-hidden="true" class="header-anchor">#</a> 析构函数</h2> <p>执行在类的实例被销毁之前需要的清理或释放非托管资源的行为
如果坚持使用 .NET 类，就不需要为类编写析构函数</p> <h2 id="readonly-修饰符"><a href="#readonly-修饰符" aria-hidden="true" class="header-anchor">#</a> readonly 修饰符</h2> <p>字段可以用 readonly 修饰符声明。一旦值被设定，就不能被修改</p> <ul><li>const 只能在字段的声明语句中初始化， readonly 字段可以在下列任意位置设置值：
<ul><li>字段声明语句，和 const 一样</li> <li>类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成</li></ul></li> <li>const 字段的值必须在编译时决定，而 readonly 字段的值可以在运行时决定</li> <li>const 的行为总是静态的，readonly 下面两点是正确的：
<ul><li>它可以是实例字段，也可以是静态字段</li> <li>它在内存中有存储位置</li></ul></li></ul> <div class="language-c# extra-class"><pre class="language-text"><code>        class Shape
        {
            readonly double PI = 3.14;
            readonly double Length;

            public Shape() {
                Length = 4,
                ...
            }

            public Shape(double side) {
                Length = 5,
            }
        }
</code></pre></div><h2 id="this-关键字"><a href="#this-关键字" aria-hidden="true" class="header-anchor">#</a> this 关键字</h2> <p>在类中使用，是对当前实例的引用。只能被用在下列类成员的代码块中：</p> <ul><li>实例构造函数</li> <li>实例方法</li> <li>属性和索引器的实例访问器</li></ul> <p>静态成员不是实例的一部，所以不能再任何静态函数成员的代码中使用 this 关键字
this 用于：</p> <ul><li>区分类的成员和本地变量或参数</li> <li>作为调用方法的实参</li></ul> <h2 id="索引器"><a href="#索引器" aria-hidden="true" class="header-anchor">#</a> 索引器</h2> <p>是一组 get 和 set 访问器，与属性类似</p> <ul><li>和属性一样，不用分配内存来存储</li> <li>都主要被用来访问其他数据成员，他们与这些成员关联，并未他们提供获取和设置访问
<ul><li>属性通常表示单独的数据成员</li> <li>所以其通常表示多个数据成员</li></ul></li> <li>和属性一样，可以有一个访问器，也可以两个都有</li> <li>索引器总是实例成员，因为不能声明为 static</li> <li>和属性一样，实现 set 和 get 的代码不一定要关联到某个字段或属性。这段代码可以做任何事情，也可以什么都不做，只要 get 返回相应类型的值即可</li></ul> <h2 id="声明索引器"><a href="#声明索引器" aria-hidden="true" class="header-anchor">#</a> 声明索引器</h2> <ul><li>索引器没有名称，在名称的位置是索引器</li> <li>参数列表在方括号中间</li> <li>参数列表中必须至少声明一个参数</li></ul> <div class="language-c# extra-class"><pre class="language-text"><code>        class Program
        {
            static void Main(string[] args)
            {
                var a = new HH();
                a[0] = 3;
                Console.WriteLine(a[0]);
                Console.WriteLine(a[1]);

                Console.WriteLine(&quot;你好&quot;);
                Console.ReadKey();
            }
        }

        public class HH
        {
            public int age { get;set; }

            public int this[int index] {
                set {
                    if (index == 0)
                    {
                        age = value;
                    }
                }
                get {
                    return age;
                }
            }
        }
</code></pre></div><h2 id="索引器重载"><a href="#索引器重载" aria-hidden="true" class="header-anchor">#</a> 索引器重载</h2> <p>只要索引器的参数列表不同，类就可以有任意多个索引器。</p> <h2 id="访问器的访问修饰符"><a href="#访问器的访问修饰符" aria-hidden="true" class="header-anchor">#</a> 访问器的访问修饰符</h2> <ul><li>仅当成员（属性或索引器）既有 get 访问器和 set 访问器，其访问器才能有访问修饰符</li> <li>虽然两个访问器都必须出现，但是只能有一个有访问修饰符</li> <li>访问器的访问修饰符必须比成员的访问级别有更严格的限制性</li></ul> <p>层级： public -&gt; protected internal -&gt; protected, internal -&gt; private</p> <p>只能低</p> <h2 id="分部类和分布类型"><a href="#分部类和分布类型" aria-hidden="true" class="header-anchor">#</a> 分部类和分布类型</h2> <ul><li>每个分部类的声明都含有一些类成员的声明</li> <li>类的分部类声明可以在一个文件，也可以不在同一个文件</li></ul> <div class="language-C# extra-class"><pre class="language-text"><code>        partial class Hello
        {
            public string name { get; set; }
        }

        partial class Hello
        {
            public string sex { get; set; }
        }
</code></pre></div><p>组成类的所有分部类声明必须在一起编译。
使用分部类声明的类必须有相同的含义，就好像所有类成员都声明在一个单独的类声明体中
除了分部类，还可以创建爱你另外两种分部类型：局部接口和局部结构</p> <h2 id="分部方法"><a href="#分部方法" aria-hidden="true" class="header-anchor">#</a> 分部方法</h2> <p>必须在分部类或分布结构内声明</p> <p>两个部分：</p> <ol><li>定义分部方法声明：
<ul><li>给出签名和返回类型</li> <li>声明的实现部分知识一个分号</li></ul></li> <li>实现分部方法声明
<ul><li>给出签名和返回类型</li> <li>是以正常形式的语句块实现</li></ul></li></ol> <ul><li>定义声明和实现声明的签名和返回类型必须匹配。
<ul><li>签名和返回类型：
<ul><li>返回类型必须是 void</li> <li>签名不能包括访问修饰符</li> <li>参数列表不能包含 out 参数</li> <li>在定义声明和实现声明中都必须包含上下文关键字 partial，直接放在 void 之前</li></ul></li></ul></li> <li>可以有定义部分，没有定义实现</li> <li>分部方法是隐式私有的</li></ul> <div class="language-C# extra-class"><pre class="language-text"><code>        partial class Hello
        {
            public string name { get; set; }
        }

        partial class Hello
        {
            public int sum { get; set; }


            partial void Sum(int x, int y);
            partial void Sum(int x, int y)
            {
                sum = x + y;
            }

            public int Add(int x, int y)
            {
                Sum(x, y);
                return sum;
            }
         }

        class Program
        {
            static void Main(string[] args)
            {
                Hello hello = new Hello();
                var sum = hello.Add(3, 8); // sum = 11;
                Console.ReadKey();
            }
        }
</code></pre></div><h2 id="类和继承"><a href="#类和继承" aria-hidden="true" class="header-anchor">#</a> 类和继承</h2> <p>除了 Object，所有的类都是派生类
派生类不能删除它继承的任何成员，但可以使用与基类成员名称相同的成员来屏蔽基类成员。 相同的签名。签名由名称和参数列表组成。 使用 new 字符。也可以屏蔽静态成员</p> <div class="language-C# extra-class"><pre class="language-text"><code>
    public class Program
    {
        static void Main(string[] args)
        {
            Chirdren chirdren = new Chirdren();
            Father father = (Father)chirdren; //基类部分的引用被储存，其他则不可见
            Console.WriteLine(father.score);

            Console.WriteLine(&quot;你好&quot;);
            Console.ReadKey();
        }
    }

    public class Father
    {
        public int score = 1;
        public int age { get; set; }
        public string name { get; set; }
    }

    public class Chirdren : Father
    {
        new public int age { get; set; }
        new public int score = 2; //隐藏了基类的字段

        public void Print()
        {
            Console.WriteLine(&quot;子类：&quot; + score);
            Console.WriteLine(&quot;父类：&quot; + base.score); //如果如果经常使用这个特性，可能要重新评估类的设计，一般来说能有更优雅的设计
        }
    }

</code></pre></div><h2 id="虚方法和覆写方法"><a href="#虚方法和覆写方法" aria-hidden="true" class="header-anchor">#</a> 虚方法和覆写方法</h2> <p>虚方法可以使基类的引用访问升至<strong>派生类</strong></p> <ul><li>派生类的方法和基类的方法具有相同的签名和返回类型</li> <li>基类的方法用 virtual</li> <li>派生类的方法用 override</li> <li>覆写和被覆写的方法必须具有相同的访问器</li> <li>不能覆写 static 方法或非虚方法</li> <li>方法、属性和索引器，以及另一种成员类型事件，都可以被声明为 virtual 和 override</li></ul> <div class="language-C# extra-class"><pre class="language-text"><code>
    public class Father
    {
        public virtual void Print() {
            Console.WriteLine(&quot;我是父类方法&quot;);
        }
    }

    public class Chirdren : Father
    {

        public override void Print()
        {
            Console.WriteLine(&quot;我是子类方法&quot;);
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            Chirdren chirdren = new Chirdren();
            Father father = (Father)chirdren;
            father.Print(); //我是子类方法

            Console.WriteLine(&quot;你好&quot;);
            Console.ReadKey();
        }
    }

</code></pre></div><ul><li>覆写方法可以在继承的任何层次出现</li> <li>当使用对象基类部分的引用调用一个覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为 override 的方法的最高派生</li> <li>如果在更高的派生级别有该方法的其他声明，但没有被标记为 override，那么他们不会被调用</li></ul> <h2 id="构造方法的执行"><a href="#构造方法的执行" aria-hidden="true" class="header-anchor">#</a> 构造方法的执行</h2> <ol><li>初始化实例成员</li> <li>调用基类构造函数</li> <li>执行实例构造函数的方法体</li></ol> <h2 id="构造函数初始化语句"><a href="#构造函数初始化语句" aria-hidden="true" class="header-anchor">#</a> 构造函数初始化语句</h2> <ul><li>使用关键字 <strong>base</strong> 并指明使用哪一个基类构造函数</li> <li>使用关键字 <strong>this</strong> 并指明应当使用当前类的哪一个构造函数</li></ul> <h2 id="类访问修饰符"><a href="#类访问修饰符" aria-hidden="true" class="header-anchor">#</a> 类访问修饰符</h2> <p>public：可以被系统内<strong>任何程序集</strong>中的代码访问
internal：只能被它<strong>自己的程序集</strong>访问</p> <h2 id="程序集间的继承"><a href="#程序集间的继承" aria-hidden="true" class="header-anchor">#</a> 程序集间的继承</h2> <p>增加对其他程序集的引用和增加 using 指令是两回事。
增加对其他程序集的引用：告诉编译器所需的类型在哪里定义
增加 using 指令：允许你引用其他的类而不必使用它们的完全限定名称</p> <div class="language-C# extra-class"><pre class="language-text"><code>//源文件名称为 Assembly1.cs
using System;

namespace BaseClass {
    public class MyClass {
        public void Print () {
            Console.WriteLine(&quot;&quot;);
        }
    }
}

</code></pre></div><p>MyClass 类是一个声明在名称为 Assembly1.cs 的源文件中，位于 BaseClass 的命名空间内部</p> <h2 id="成员访问修饰符"><a href="#成员访问修饰符" aria-hidden="true" class="header-anchor">#</a> 成员访问修饰符</h2> <p>判断条件：</p> <ul><li>是否是继承</li> <li>是否在相同程序集</li></ul> <p>public
private：只能被自己的类的成员访问，包括继承的类。但是可以被嵌套在它的类中的类成员访问
protected：允许继承的类访问，不在乎程序集
internal：对同一个程序集内部的任何类成员可见
protected internal：protected 和 interna 的并集</p> <ul><li>如果不指定成员访问级别，则为 private</li></ul> <h2 id="抽象成员"><a href="#抽象成员" aria-hidden="true" class="header-anchor">#</a> 抽象成员</h2> <p>被设计为被覆写的<strong>函数成员</strong></p> <ul><li>必须为一个函数成员</li> <li>必须用 abstract</li> <li>不能有实现代码块</li> <li>只可以在抽象类中声明：方法、属性、事件、索引</li> <li>派生类的抽象成员的实现必须指定 override 修饰符</li></ul> <h2 id="抽象类"><a href="#抽象类" aria-hidden="true" class="header-anchor">#</a> 抽象类</h2> <p>被设计为被继承的<strong>类</strong>，只能用作基类
可以包含抽象成员或普通的非抽象成员
任何派生自抽象类的类必须使用 override 关键字实现该类所有的抽象成员，除非派生类自己也是抽象类</p> <h2 id="密封类"><a href="#密封类" aria-hidden="true" class="header-anchor">#</a> 密封类</h2> <ul><li>只能被用作独立的类，不能用作基类</li> <li>用 sealed 修饰符</li></ul> <h3 id="静态类"><a href="#静态类" aria-hidden="true" class="header-anchor">#</a> 静态类</h3> <ul><li>所有成员都是静态的。</li> <li>用于存放不受实例数据影响的数据和函数</li> <li>是隐式密封的</li></ul> <h2 id="扩展类"><a href="#扩展类" aria-hidden="true" class="header-anchor">#</a> 扩展类</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/CSharp/基础/枚举.html" class="prev">
          枚举
        </a></span> <span class="next"><a href="/CSharp/基础/结构.html">
          结构
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.95515c58.js" defer></script><script src="/assets/js/2.1e63c646.js" defer></script><script src="/assets/js/11.7d9955f5.js" defer></script>
  </body>
</html>
