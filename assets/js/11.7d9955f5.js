(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{198:function(a,t,e){"use strict";e.r(t);var n=e(0),i=Object(n.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类","aria-hidden":"true"}},[a._v("#")]),a._v(" 类")]),a._v(" "),e("h2",{attrs:{id:"属性和关联的字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性和关联的字段","aria-hidden":"true"}},[a._v("#")]),a._v(" 属性和关联的字段")]),a._v(" "),e("p",[e("strong",[a._v("后备字段")]),a._v("：和属性关联的字段,分配字段\n"),e("strong",[a._v("属性")]),a._v("不分配字段")]),a._v(" "),e("h2",{attrs:{id:"属性和公共字段"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#属性和公共字段","aria-hidden":"true"}},[a._v("#")]),a._v(" 属性和公共字段")]),a._v(" "),e("p",[a._v("按照推荐的编程实践，属性比公共字段好：")]),a._v(" "),e("ul",[e("li",[a._v("属性是函数成员，而不是数据成员，可以进行输入和输出，而公共字段不行")]),a._v(" "),e("li",[a._v("属性可以只读和只写，公共字段不行")]),a._v(" "),e("li",[a._v("编译后的变量和编译后的属性语义不同")])]),a._v(" "),e("h2",{attrs:{id:"自动实现属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动实现属性","aria-hidden":"true"}},[a._v("#")]),a._v(" 自动实现属性")]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("        clsss Test\n        {\n            public int MyValue\n            {\n                get;\n                set;\n            }\n\n\n        }\n")])])]),e("ul",[e("li",[a._v("不声明后备字段,编译器会根据属性的类型分配存储")]),a._v(" "),e("li",[a._v("不能提供访问器的方法体，他们必须被简单的声明为分号。")]),a._v(" "),e("li",[a._v("除非通过访问器，否则不能访问后备字段")])]),a._v(" "),e("h2",{attrs:{id:"静态属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态属性","aria-hidden":"true"}},[a._v("#")]),a._v(" 静态属性")]),a._v(" "),e("ul",[e("li",[a._v("不能访问类的实例成员，可以被实例成员访问到")]),a._v(" "),e("li",[a._v("不管类是否有实例，他们都是存在的")]),a._v(" "),e("li",[a._v("当从类的外部访问时，必须使用类名引用，而不是实例名")])]),a._v(" "),e("h2",{attrs:{id:"实例构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实例构造函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 实例构造函数")]),a._v(" "),e("p",[a._v("是一个特殊的方法，在创建类的每个新实例时执行")]),a._v(" "),e("ul",[e("li",[a._v("用于初始化类实例的状态")]),a._v(" "),e("li",[a._v("如果希望能从类的外部创建类的实例，需要将构造函数声明为 public")]),a._v(" "),e("li",[a._v("构造函数的名称和类的名称相同")]),a._v(" "),e("li",[a._v("构造函数不能有返回值")])]),a._v(" "),e("h2",{attrs:{id:"带参数的构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#带参数的构造函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 带参数的构造函数")]),a._v(" "),e("ul",[e("li",[a._v("构造函数可以带参数")]),a._v(" "),e("li",[a._v("构造函数可以被重载")])]),a._v(" "),e("h2",{attrs:{id:"默认构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#默认构造函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 默认构造函数")]),a._v(" "),e("ul",[e("li",[a._v("没有参数")]),a._v(" "),e("li",[a._v("方法体为空")]),a._v(" "),e("li",[a._v("如果声明了任何构造函数，则编译器将不会为该类定义默认构造函数")])]),a._v(" "),e("h2",{attrs:{id:"静态构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态构造函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 静态构造函数")]),a._v(" "),e("p",[a._v("构造函数可以声明为 static，实例构造函数初始化类的每个新实例，而 static 构造函数初始化类级别的项。通常，静态构造函数初始化类的静态字段。")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("初始化类级别的项")])]),a._v(" "),e("li",[e("strong",[a._v("在引用任何静态成员之前")])]),a._v(" "),e("li",[e("strong",[a._v("在创建类的任何实例之前")])]),a._v(" "),e("li",[a._v("静态构造函数的名称必须和类名相同")]),a._v(" "),e("li",[a._v("不能有返回值")]),a._v(" "),e("li",[a._v("static关键字")]),a._v(" "),e("li",[e("strong",[a._v("只能有一个静态构造函数，且不能带参数")])]),a._v(" "),e("li",[a._v("类既可以有静态构造函数，也可以有实例构造函数")]),a._v(" "),e("li",[a._v("不能访问所在类的实例成员，因此也不能使用 this 访问器")]),a._v(" "),e("li",[a._v("不能从程序中显式调用静态构造函数，系统会自动调用：\n"),e("ul",[e("li",[a._v("类的任何实例被创建之前")]),a._v(" "),e("li",[a._v("类的任何静态成员被引用之前")])])])]),a._v(" "),e("h2",{attrs:{id:"对象初始化语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对象初始化语句","aria-hidden":"true"}},[a._v("#")]),a._v(" 对象初始化语句")]),a._v(" "),e("div",{staticClass:"language-c# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("    new TypeName { x = 1, y =2}\n    new TypeName() { x = 1, y =2 }\n")])])]),e("ul",[e("li",[a._v("创建对象必须能都访问要初始化的字段和属性")]),a._v(" "),e("li",[e("strong",[a._v("初始化发生在构造函数之后")])])]),a._v(" "),e("h2",{attrs:{id:"析构函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#析构函数","aria-hidden":"true"}},[a._v("#")]),a._v(" 析构函数")]),a._v(" "),e("p",[a._v("执行在类的实例被销毁之前需要的清理或释放非托管资源的行为\n如果坚持使用 .NET 类，就不需要为类编写析构函数")]),a._v(" "),e("h2",{attrs:{id:"readonly-修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#readonly-修饰符","aria-hidden":"true"}},[a._v("#")]),a._v(" readonly 修饰符")]),a._v(" "),e("p",[a._v("字段可以用 readonly 修饰符声明。一旦值被设定，就不能被修改")]),a._v(" "),e("ul",[e("li",[a._v("const 只能在字段的声明语句中初始化， readonly 字段可以在下列任意位置设置值：\n"),e("ul",[e("li",[a._v("字段声明语句，和 const 一样")]),a._v(" "),e("li",[a._v("类的任何构造函数。如果是 static 字段，初始化必须在静态构造函数中完成")])])]),a._v(" "),e("li",[a._v("const 字段的值必须在编译时决定，而 readonly 字段的值可以在运行时决定")]),a._v(" "),e("li",[a._v("const 的行为总是静态的，readonly 下面两点是正确的：\n"),e("ul",[e("li",[a._v("它可以是实例字段，也可以是静态字段")]),a._v(" "),e("li",[a._v("它在内存中有存储位置")])])])]),a._v(" "),e("div",{staticClass:"language-c# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("        class Shape\n        {\n            readonly double PI = 3.14;\n            readonly double Length;\n\n            public Shape() {\n                Length = 4,\n                ...\n            }\n\n            public Shape(double side) {\n                Length = 5,\n            }\n        }\n")])])]),e("h2",{attrs:{id:"this-关键字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this-关键字","aria-hidden":"true"}},[a._v("#")]),a._v(" this 关键字")]),a._v(" "),e("p",[a._v("在类中使用，是对当前实例的引用。只能被用在下列类成员的代码块中：")]),a._v(" "),e("ul",[e("li",[a._v("实例构造函数")]),a._v(" "),e("li",[a._v("实例方法")]),a._v(" "),e("li",[a._v("属性和索引器的实例访问器")])]),a._v(" "),e("p",[a._v("静态成员不是实例的一部，所以不能再任何静态函数成员的代码中使用 this 关键字\nthis 用于：")]),a._v(" "),e("ul",[e("li",[a._v("区分类的成员和本地变量或参数")]),a._v(" "),e("li",[a._v("作为调用方法的实参")])]),a._v(" "),e("h2",{attrs:{id:"索引器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引器","aria-hidden":"true"}},[a._v("#")]),a._v(" 索引器")]),a._v(" "),e("p",[a._v("是一组 get 和 set 访问器，与属性类似")]),a._v(" "),e("ul",[e("li",[a._v("和属性一样，不用分配内存来存储")]),a._v(" "),e("li",[a._v("都主要被用来访问其他数据成员，他们与这些成员关联，并未他们提供获取和设置访问\n"),e("ul",[e("li",[a._v("属性通常表示单独的数据成员")]),a._v(" "),e("li",[a._v("所以其通常表示多个数据成员")])])]),a._v(" "),e("li",[a._v("和属性一样，可以有一个访问器，也可以两个都有")]),a._v(" "),e("li",[a._v("索引器总是实例成员，因为不能声明为 static")]),a._v(" "),e("li",[a._v("和属性一样，实现 set 和 get 的代码不一定要关联到某个字段或属性。这段代码可以做任何事情，也可以什么都不做，只要 get 返回相应类型的值即可")])]),a._v(" "),e("h2",{attrs:{id:"声明索引器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#声明索引器","aria-hidden":"true"}},[a._v("#")]),a._v(" 声明索引器")]),a._v(" "),e("ul",[e("li",[a._v("索引器没有名称，在名称的位置是索引器")]),a._v(" "),e("li",[a._v("参数列表在方括号中间")]),a._v(" "),e("li",[a._v("参数列表中必须至少声明一个参数")])]),a._v(" "),e("div",{staticClass:"language-c# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('        class Program\n        {\n            static void Main(string[] args)\n            {\n                var a = new HH();\n                a[0] = 3;\n                Console.WriteLine(a[0]);\n                Console.WriteLine(a[1]);\n\n                Console.WriteLine("你好");\n                Console.ReadKey();\n            }\n        }\n\n        public class HH\n        {\n            public int age { get;set; }\n\n            public int this[int index] {\n                set {\n                    if (index == 0)\n                    {\n                        age = value;\n                    }\n                }\n                get {\n                    return age;\n                }\n            }\n        }\n')])])]),e("h2",{attrs:{id:"索引器重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#索引器重载","aria-hidden":"true"}},[a._v("#")]),a._v(" 索引器重载")]),a._v(" "),e("p",[a._v("只要索引器的参数列表不同，类就可以有任意多个索引器。")]),a._v(" "),e("h2",{attrs:{id:"访问器的访问修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问器的访问修饰符","aria-hidden":"true"}},[a._v("#")]),a._v(" 访问器的访问修饰符")]),a._v(" "),e("ul",[e("li",[a._v("仅当成员（属性或索引器）既有 get 访问器和 set 访问器，其访问器才能有访问修饰符")]),a._v(" "),e("li",[a._v("虽然两个访问器都必须出现，但是只能有一个有访问修饰符")]),a._v(" "),e("li",[a._v("访问器的访问修饰符必须比成员的访问级别有更严格的限制性")])]),a._v(" "),e("p",[a._v("层级： public -> protected internal -> protected, internal -> private")]),a._v(" "),e("p",[a._v("只能低")]),a._v(" "),e("h2",{attrs:{id:"分部类和分布类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分部类和分布类型","aria-hidden":"true"}},[a._v("#")]),a._v(" 分部类和分布类型")]),a._v(" "),e("ul",[e("li",[a._v("每个分部类的声明都含有一些类成员的声明")]),a._v(" "),e("li",[a._v("类的分部类声明可以在一个文件，也可以不在同一个文件")])]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("        partial class Hello\n        {\n            public string name { get; set; }\n        }\n\n        partial class Hello\n        {\n            public string sex { get; set; }\n        }\n")])])]),e("p",[a._v("组成类的所有分部类声明必须在一起编译。\n使用分部类声明的类必须有相同的含义，就好像所有类成员都声明在一个单独的类声明体中\n除了分部类，还可以创建爱你另外两种分部类型：局部接口和局部结构")]),a._v(" "),e("h2",{attrs:{id:"分部方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分部方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 分部方法")]),a._v(" "),e("p",[a._v("必须在分部类或分布结构内声明")]),a._v(" "),e("p",[a._v("两个部分：")]),a._v(" "),e("ol",[e("li",[a._v("定义分部方法声明：\n"),e("ul",[e("li",[a._v("给出签名和返回类型")]),a._v(" "),e("li",[a._v("声明的实现部分知识一个分号")])])]),a._v(" "),e("li",[a._v("实现分部方法声明\n"),e("ul",[e("li",[a._v("给出签名和返回类型")]),a._v(" "),e("li",[a._v("是以正常形式的语句块实现")])])])]),a._v(" "),e("ul",[e("li",[a._v("定义声明和实现声明的签名和返回类型必须匹配。\n"),e("ul",[e("li",[a._v("签名和返回类型：\n"),e("ul",[e("li",[a._v("返回类型必须是 void")]),a._v(" "),e("li",[a._v("签名不能包括访问修饰符")]),a._v(" "),e("li",[a._v("参数列表不能包含 out 参数")]),a._v(" "),e("li",[a._v("在定义声明和实现声明中都必须包含上下文关键字 partial，直接放在 void 之前")])])])])]),a._v(" "),e("li",[a._v("可以有定义部分，没有定义实现")]),a._v(" "),e("li",[a._v("分部方法是隐式私有的")])]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("        partial class Hello\n        {\n            public string name { get; set; }\n        }\n\n        partial class Hello\n        {\n            public int sum { get; set; }\n\n\n            partial void Sum(int x, int y);\n            partial void Sum(int x, int y)\n            {\n                sum = x + y;\n            }\n\n            public int Add(int x, int y)\n            {\n                Sum(x, y);\n                return sum;\n            }\n         }\n\n        class Program\n        {\n            static void Main(string[] args)\n            {\n                Hello hello = new Hello();\n                var sum = hello.Add(3, 8); // sum = 11;\n                Console.ReadKey();\n            }\n        }\n")])])]),e("h2",{attrs:{id:"类和继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类和继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 类和继承")]),a._v(" "),e("p",[a._v("除了 Object，所有的类都是派生类\n派生类不能删除它继承的任何成员，但可以使用与基类成员名称相同的成员来屏蔽基类成员。 相同的签名。签名由名称和参数列表组成。 使用 new 字符。也可以屏蔽静态成员")]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('\n    public class Program\n    {\n        static void Main(string[] args)\n        {\n            Chirdren chirdren = new Chirdren();\n            Father father = (Father)chirdren; //基类部分的引用被储存，其他则不可见\n            Console.WriteLine(father.score);\n\n            Console.WriteLine("你好");\n            Console.ReadKey();\n        }\n    }\n\n    public class Father\n    {\n        public int score = 1;\n        public int age { get; set; }\n        public string name { get; set; }\n    }\n\n    public class Chirdren : Father\n    {\n        new public int age { get; set; }\n        new public int score = 2; //隐藏了基类的字段\n\n        public void Print()\n        {\n            Console.WriteLine("子类：" + score);\n            Console.WriteLine("父类：" + base.score); //如果如果经常使用这个特性，可能要重新评估类的设计，一般来说能有更优雅的设计\n        }\n    }\n\n')])])]),e("h2",{attrs:{id:"虚方法和覆写方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚方法和覆写方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 虚方法和覆写方法")]),a._v(" "),e("p",[a._v("虚方法可以使基类的引用访问升至"),e("strong",[a._v("派生类")])]),a._v(" "),e("ul",[e("li",[a._v("派生类的方法和基类的方法具有相同的签名和返回类型")]),a._v(" "),e("li",[a._v("基类的方法用 virtual")]),a._v(" "),e("li",[a._v("派生类的方法用 override")]),a._v(" "),e("li",[a._v("覆写和被覆写的方法必须具有相同的访问器")]),a._v(" "),e("li",[a._v("不能覆写 static 方法或非虚方法")]),a._v(" "),e("li",[a._v("方法、属性和索引器，以及另一种成员类型事件，都可以被声明为 virtual 和 override")])]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('\n    public class Father\n    {\n        public virtual void Print() {\n            Console.WriteLine("我是父类方法");\n        }\n    }\n\n    public class Chirdren : Father\n    {\n\n        public override void Print()\n        {\n            Console.WriteLine("我是子类方法");\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Chirdren chirdren = new Chirdren();\n            Father father = (Father)chirdren;\n            father.Print(); //我是子类方法\n\n            Console.WriteLine("你好");\n            Console.ReadKey();\n        }\n    }\n\n')])])]),e("ul",[e("li",[a._v("覆写方法可以在继承的任何层次出现")]),a._v(" "),e("li",[a._v("当使用对象基类部分的引用调用一个覆写的方法时，方法的调用被沿派生层次上溯执行，一直到标记为 override 的方法的最高派生")]),a._v(" "),e("li",[a._v("如果在更高的派生级别有该方法的其他声明，但没有被标记为 override，那么他们不会被调用")])]),a._v(" "),e("h2",{attrs:{id:"构造方法的执行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造方法的执行","aria-hidden":"true"}},[a._v("#")]),a._v(" 构造方法的执行")]),a._v(" "),e("ol",[e("li",[a._v("初始化实例成员")]),a._v(" "),e("li",[a._v("调用基类构造函数")]),a._v(" "),e("li",[a._v("执行实例构造函数的方法体")])]),a._v(" "),e("h2",{attrs:{id:"构造函数初始化语句"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数初始化语句","aria-hidden":"true"}},[a._v("#")]),a._v(" 构造函数初始化语句")]),a._v(" "),e("ul",[e("li",[a._v("使用关键字 "),e("strong",[a._v("base")]),a._v(" 并指明使用哪一个基类构造函数")]),a._v(" "),e("li",[a._v("使用关键字 "),e("strong",[a._v("this")]),a._v(" 并指明应当使用当前类的哪一个构造函数")])]),a._v(" "),e("h2",{attrs:{id:"类访问修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类访问修饰符","aria-hidden":"true"}},[a._v("#")]),a._v(" 类访问修饰符")]),a._v(" "),e("p",[a._v("public：可以被系统内"),e("strong",[a._v("任何程序集")]),a._v("中的代码访问\ninternal：只能被它"),e("strong",[a._v("自己的程序集")]),a._v("访问")]),a._v(" "),e("h2",{attrs:{id:"程序集间的继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序集间的继承","aria-hidden":"true"}},[a._v("#")]),a._v(" 程序集间的继承")]),a._v(" "),e("p",[a._v("增加对其他程序集的引用和增加 using 指令是两回事。\n增加对其他程序集的引用：告诉编译器所需的类型在哪里定义\n增加 using 指令：允许你引用其他的类而不必使用它们的完全限定名称")]),a._v(" "),e("div",{staticClass:"language-C# extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('//源文件名称为 Assembly1.cs\nusing System;\n\nnamespace BaseClass {\n    public class MyClass {\n        public void Print () {\n            Console.WriteLine("");\n        }\n    }\n}\n\n')])])]),e("p",[a._v("MyClass 类是一个声明在名称为 Assembly1.cs 的源文件中，位于 BaseClass 的命名空间内部")]),a._v(" "),e("h2",{attrs:{id:"成员访问修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#成员访问修饰符","aria-hidden":"true"}},[a._v("#")]),a._v(" 成员访问修饰符")]),a._v(" "),e("p",[a._v("判断条件：")]),a._v(" "),e("ul",[e("li",[a._v("是否是继承")]),a._v(" "),e("li",[a._v("是否在相同程序集")])]),a._v(" "),e("p",[a._v("public\nprivate：只能被自己的类的成员访问，包括继承的类。但是可以被嵌套在它的类中的类成员访问\nprotected：允许继承的类访问，不在乎程序集\ninternal：对同一个程序集内部的任何类成员可见\nprotected internal：protected 和 interna 的并集")]),a._v(" "),e("ul",[e("li",[a._v("如果不指定成员访问级别，则为 private")])]),a._v(" "),e("h2",{attrs:{id:"抽象成员"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象成员","aria-hidden":"true"}},[a._v("#")]),a._v(" 抽象成员")]),a._v(" "),e("p",[a._v("被设计为被覆写的"),e("strong",[a._v("函数成员")])]),a._v(" "),e("ul",[e("li",[a._v("必须为一个函数成员")]),a._v(" "),e("li",[a._v("必须用 abstract")]),a._v(" "),e("li",[a._v("不能有实现代码块")]),a._v(" "),e("li",[a._v("只可以在抽象类中声明：方法、属性、事件、索引")]),a._v(" "),e("li",[a._v("派生类的抽象成员的实现必须指定 override 修饰符")])]),a._v(" "),e("h2",{attrs:{id:"抽象类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类","aria-hidden":"true"}},[a._v("#")]),a._v(" 抽象类")]),a._v(" "),e("p",[a._v("被设计为被继承的"),e("strong",[a._v("类")]),a._v("，只能用作基类\n可以包含抽象成员或普通的非抽象成员\n任何派生自抽象类的类必须使用 override 关键字实现该类所有的抽象成员，除非派生类自己也是抽象类")]),a._v(" "),e("h2",{attrs:{id:"密封类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#密封类","aria-hidden":"true"}},[a._v("#")]),a._v(" 密封类")]),a._v(" "),e("ul",[e("li",[a._v("只能被用作独立的类，不能用作基类")]),a._v(" "),e("li",[a._v("用 sealed 修饰符")])]),a._v(" "),e("h3",{attrs:{id:"静态类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态类","aria-hidden":"true"}},[a._v("#")]),a._v(" 静态类")]),a._v(" "),e("ul",[e("li",[a._v("所有成员都是静态的。")]),a._v(" "),e("li",[a._v("用于存放不受实例数据影响的数据和函数")]),a._v(" "),e("li",[a._v("是隐式密封的")])]),a._v(" "),e("h2",{attrs:{id:"扩展类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展类","aria-hidden":"true"}},[a._v("#")]),a._v(" 扩展类")])])},[],!1,null,null,null);t.default=i.exports}}]);