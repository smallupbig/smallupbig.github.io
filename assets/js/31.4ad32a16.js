(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{196:function(t,v,_){"use strict";_.r(v);var a=_(0),e=Object(a.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("p",[t._v("[TOC]")]),t._v(" "),_("h3",{attrs:{id:"将源代码编译成托管模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#将源代码编译成托管模块","aria-hidden":"true"}},[t._v("#")]),t._v(" 将源代码编译成托管模块")]),t._v(" "),_("p",[t._v("公共语言运行时（Common Language Runtime, CLR)：一个可由多种编程语言使用的“运行时”")]),t._v(" "),_("p",[t._v("CLR 的核心功能（比如内存管理、程序集加载、安全性、异常处理和线程同步）可由面向 CLR 的所有语言使用。")]),t._v(" "),_("p",[t._v("无论选择哪个编译器，结果都是托管模块（managed module）")]),t._v(" "),_("p",[t._v("托管模块：标准的32位 Microsoft Windows 可移植执行体（PE32）文件或标准的64位，都需要 CLR 才能执行。")]),t._v(" "),_("p",[t._v("可移植执行体：PE（Portable Executable）")]),t._v(" "),_("p",[t._v("托管程序集总是利用 Windows 的数据执行保护（Data Execution Prevention，DEP）和地址空间布局随机化（Address Space Layout Randomization，ASLR），这两个功能旨在增强整个系统的安全性。")]),t._v(" "),_("h4",{attrs:{id:"托管模块"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#托管模块","aria-hidden":"true"}},[t._v("#")]),t._v(" 托管模块")]),t._v(" "),_("ol",[_("li",[_("p",[t._v("PE32 或 PE32+头")])]),t._v(" "),_("li",[_("p",[t._v("CLR 头:包含使用这个模块成为托管模块的信息（可由 CLR 和一些实用程序进行解释）")])]),t._v(" "),_("li",[_("p",[t._v("元数据：每个托管模块都包含元数据表。")]),t._v(" "),_("ul",[_("li",[t._v("主要有两种表：\n"),_("ul",[_("li",[t._v("描述源代码中定义的类型和成员")]),t._v(" "),_("li",[t._v("描述源代码引用的类型和成员")])])]),t._v(" "),_("li",[t._v("用途（部分）：\n"),_("ul",[_("li",[t._v("避免了编译时对原生 C/C++头和库文件的需求，因为在实现类型/成员的 IL 代码文件中，已包含有关引用类型/成员的全部信息。编译器直接从托管模块读取元数据。")]),t._v(" "),_("li",[t._v("VS 用元数据帮助你写代码。智能感知（IntelliSense）技术会解析元数据，告诉一个类型提供了哪些方法、属性、事件和字段。对于方法，还能告诉你需要的参数。")]),t._v(" "),_("li",[t._v("CLR 的代码验证过程使用元数据确保代码只执行“类型安全”的操作")]),t._v(" "),_("li",[t._v("元数据允许将对象的字段序列化到内存块，将其发送给另一条机器，然后反序列化，在远程机器上重建对象状态。")]),t._v(" "),_("li",[t._v("元数据允许垃圾回收器跟踪对象生存期。垃圾回收器能判断任何对象的类型，并从元数据知道那个对象的哪些字段引用了其他对象。")])])])])]),t._v(" "),_("li",[_("p",[t._v("IL（中间语言）代码：编译器编译源代码生成的代码。在运行时，CLR 将 IL 编译成本机 CPU 指令")])])]),t._v(" "),_("p",[t._v("Microsoft 的 C++ 编译器默认生成包含非托管（native）代码的 EXE/DLL 模块，并在运行时操纵非托管数据（native 内存）。这些模块不需要 CLR 即可执行。然而，通过制定 CLR 命令行开关，C++ 编译器就能生成包含托管代码的模块，当然，最终用户必须安装 CLR 才能执行这种代码。")]),t._v(" "),_("h4",{attrs:{id:"将托管模块合并成程序集"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#将托管模块合并成程序集","aria-hidden":"true"}},[t._v("#")]),t._v(" 将托管模块合并成程序集")]),t._v(" "),_("p",[t._v("CLR 实际不和模块工作。和程序集工作。")]),t._v(" "),_("p",[_("strong",[t._v("程序集")]),t._v("（assembly）是一个或多个模块/资源文件的逻辑性分组。其次，程序集是重用、安全性以及版本控制的最小单元。取决于你选择的编译器或工具，既可生产单文件程序集，也可生成多文件程序集。")]),t._v(" "),_("p",[t._v("在 CLR 的世界里，程序集相当于组件。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://github.com/smallupbig/MyNote/blob/master/Res/pic_CLR/1_1.png",alt:"1.1将托管模块合并成程序集"}})]),t._v(" "),_("p",[t._v("在程序集的模块中，还包含与引用的程序集有关的信息（包括它们的版本号）。这些信息使程序集能够自描述（self-describing）。也就是，CLR 能判断为了执行程序集的代码，程序集的直接依赖对象（immediate dependency)是什么。不需要注册表或 Active Directory Domain Services(ADDS)中保存额外的信息。由于无需额外信息，所以和非托管组件相比，程序集更容易部署。")]),t._v(" "),_("h4",{attrs:{id:"加载公共语言运行时"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加载公共语言运行时","aria-hidden":"true"}},[t._v("#")]),t._v(" 加载公共语言运行时")]),t._v(" "),_("p",[t._v("生成的每个程序集既可以是可执行应用程序，也可以是 DLL（其中含有一组由可执行程序使用的类型）。最终是由 CLR 管理这些程序集中的代码的执行。")]),t._v(" "),_("h4",{attrs:{id:"执行程序集的代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#执行程序集的代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 执行程序集的代码")]),t._v(" "),_("p",[t._v("托管程序集同时包含元数据和IL。\n"),_("strong",[t._v("IL")]),t._v(" 是与 CPU 无关的机器语言，是 Microsoft 在请教了外面的几个商业及学术性语言/编译器的作者之后，费尽心思开发出来的。\n"),_("strong",[t._v("IL")]),t._v(" 比大多数 CPU 机器语言都高级。\n"),_("strong",[t._v("IL")]),t._v(" 能访问和操作对象类型，并提供了指令来创建和初始化对象、调用对象上的虚方法以及直接操作数组元素。甚至提供了抛出和捕捉异常的指令来实现错误处理。可将 IL 视为一种面向对象的机器语言。\n高级语言通常只公开了 CLR 全部功能的一个自己。然而，IL 汇编语言允许开发人员访问 CLR 的全部功能。所以，如果选择的编程语言隐藏了迫切需要的一个 CLR 功能，可以换用 IL 汇编语言或者提供了所需功能的另一种编程语言来写那部分代码。\n为了执行方法，首先要把方法的 IL 转换成本机（native）CPU 指令。这是 CLR 的 JIT（just-in-time）编译器的职责。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://github.com/smallupbig/MyNote/blob/master/Res/pic_CLR/1_2.png",alt:"1.2执行程序集的代码"}}),t._v(" "),_("img",{attrs:{src:"https://github.com/smallupbig/MyNote/blob/master/Res/pic_CLR/1_3.png",alt:"1.3方法的第二次调用"}})]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("编辑器开关设置")]),t._v(" "),_("th",[t._v("C# IL 代码质量")]),t._v(" "),_("th",[t._v("JIT 本机代码质量")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("/optimize-/debug-(默认)")]),t._v(" "),_("td",[t._v("未优化")]),t._v(" "),_("td",[t._v("有优化")])]),t._v(" "),_("tr",[_("td",[t._v("/optimize-/debug(+/full/pdbonly)")]),t._v(" "),_("td",[t._v("未优化")]),t._v(" "),_("td",[t._v("未优化")])]),t._v(" "),_("tr",[_("td",[t._v("/optimize+/debug(-/+/full/pdbonly)")]),t._v(" "),_("td",[t._v("有优化")]),t._v(" "),_("td",[t._v("有优化")])])])]),t._v(" "),_("p",[_("strong",[t._v("JIT")]),t._v(" 优势：")]),t._v(" "),_("ul",[_("li",[t._v("JIT 编译器能判断应用程序是否运行在 Inter Pentium 4 CPU 上，并生成相应的本机代码来利用 Pentium 4 支持的任何特殊指令。")]),t._v(" "),_("li",[t._v("JIT 编译器能判断一个特定的测试在它运行的机器上是否总是失败。例如")])]),t._v(" "),_("div",{staticClass:"language-C# extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("\tif (numberOfCPUs > 1) {\n\t\t...\n\t}\n")])])]),_("p",[t._v("如果本机只有一个 CPU，JIT 编译器不会为上述代码生成任何 CPU 指令，在这种情况下，本机代码将针对主机进行优化，最终代码变得更小，执行得更快")]),t._v(" "),_("ul",[_("li",[t._v("。。。")])]),t._v(" "),_("h4",{attrs:{id:"il-和验证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#il-和验证","aria-hidden":"true"}},[t._v("#")]),t._v(" IL 和验证")]),t._v(" "),_("p",[t._v("IL 基于栈。\nIL 指令是无类型的（不分 32 位和 64 位，自己进行判断）\n将 IL 编译成本机 CPU 指令时，CLR 执行一个名为验证的过程。会去检查高级 IL 代码，确定代码所做的一切都是安全的。\nWindows 的每个进程都有自己的虚拟地址空间。独立地址空间之所以重要，是因为不能简单的信任一个应用程序的代码。应用程序完全可能读写无效的内存条地址。将每个 Windows 进程都放到独立的地址空间，将获得健壮性与稳定性：一个进程干扰不到另一个进程。  然而，通过验证托管代码，可以确保代码不会不正确地访问内存，不会干扰到另一个应用程序的代码。这样就可以放心地将多个托管应用程序放到同一个 Windows 虚拟地址空间运行。\n由于 Windows 进程需要大量操作系统资源，所以进程数量太多，会损害性能并制约可用的资源。用一个进程运行多个应用程序，可减少进程数，从而增强性能，减少所需的资源\n，健壮性也没有丝毫下降。这是托管代码相较于非托管代码的另一个优势。")]),t._v(" "),_("h4",{attrs:{id:"不安全的代码"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#不安全的代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 不安全的代码")]),t._v(" "),_("h4",{attrs:{id:"本机代码生成器：ngen-exe"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本机代码生成器：ngen-exe","aria-hidden":"true"}},[t._v("#")]),t._v(" 本机代码生成器：NGen.exe")]),t._v(" "),_("p",[t._v("可以在应用程序安装到用户的计算机上去时，将 IL 代码编译成本机代码。\n优点：")]),t._v(" "),_("ol",[_("li",[t._v("提高应用程序的启动速度")]),t._v(" "),_("li",[t._v("减小应用程序的工作集\n缺点：")]),t._v(" "),_("li",[t._v("没有知识产权保护")]),t._v(" "),_("li",[t._v("NGen 生成的文件可能失去同步\nCLR 加载 NGen 生成的文件时，会将预编译代码的许多特征与当前执行环境进行比较。任何特征不匹配，NGen 生成的文件就不能用，就要改为使用正常的 JIT 编译器进程。\n如：\n"),_("ul",[_("li",[t._v("CLR 版本：随补丁或 Service Pack 改变")]),t._v(" "),_("li",[t._v("CPU 类型：升级处理器发生改变")]),t._v(" "),_("li",[t._v("WIndows 操作系统版本：安装新 Service Pack 后改变")]),t._v(" "),_("li",[t._v("程序集的标识模块版本 ID（Module Version ID， MVID）：重新编译后改变")]),t._v(" "),_("li",[t._v("引用的程序集的版本 ID：重新编译引用的程序集后改变")]),t._v(" "),_("li",[t._v("安全性：吊销了额之前授予的权限之后，安全性就会发生改变。")])])]),t._v(" "),_("li",[t._v("较差的执行时性能\n编译代码时，NGen 无法像 JIT 编译器那样对执行环境进行许多假定。会生成交叉的代码")])]),t._v(" "),_("h4",{attrs:{id:"framework-类库（fcl）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#framework-类库（fcl）","aria-hidden":"true"}},[t._v("#")]),t._v(" Framework 类库（FCL）")]),t._v(" "),_("h4",{attrs:{id:"通用类型系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通用类型系统","aria-hidden":"true"}},[t._v("#")]),t._v(" 通用类型系统")]),t._v(" "),_("p",[t._v("通用类型系统（Common Type System，CTS）")]),t._v(" "),_("h4",{attrs:{id:"公共语言规范（common-language-specification，-cls）"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#公共语言规范（common-language-specification，-cls）","aria-hidden":"true"}},[t._v("#")]),t._v(" 公共语言规范（Common Language Specification， CLS）")]),t._v(" "),_("p",[t._v("详细定义了一个最小功能集。任何编译器只有支持这个功能集，生成的类型才能兼容由其他符合 CLS、面向 CLS 的语言生成的组件。")]),t._v(" "),_("h4",{attrs:{id:"与非托管代码的互操作性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#与非托管代码的互操作性","aria-hidden":"true"}},[t._v("#")]),t._v(" 与非托管代码的互操作性")]),t._v(" "),_("ul",[_("li",[t._v("托管代码能调用 DLL 中的非托管函数")]),t._v(" "),_("li",[t._v("托管代码可以使用现有的 COM 组件（服务器）")]),t._v(" "),_("li",[t._v("非托管代码可以使用托管类型（服务器）")])])])},[],!1,null,null,null);v.default=e.exports}}]);